🧩 Problem: Find Peak Element

Statement:
Given an integer array nums, find a peak element — an element that is strictly greater than its neighbors.
Return the index of any one peak element.
You may assume nums[-1] = nums[n] = -∞.

Goal:
Find the index of a peak element in O(log n) time.

💡 Key Idea / Observation

A peak element satisfies:
nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]

The array has a “mountain-like” structure — if you move in the direction of the higher neighbor, you’ll eventually reach a peak.

So, using binary search logic, you can decide which half to explore next.

⚙️ Algorithm (Binary Search)

Handle edge cases first:

If array size is 1 → only element is the peak.

If first element is greater than the second → peak is at index 0.

If last element is greater than the second last → peak is at index n - 1.

Binary search between 1 and n - 2:

Compute mid = (low + high) / 2

If nums[mid] is greater than both neighbors → return mid

If the slope is ascending (nums[mid] >= nums[mid - 1]) → move right

Else → move left

If no peak found (theoretically shouldn’t happen), return -1.

🧠 Why Binary Search Works

If nums[mid] > nums[mid - 1], you are on an ascending slope — so a peak must exist to the right.

If nums[mid] < nums[mid - 1], you are on a descending slope — so a peak must exist to the left.

Hence, by halving the search space each time, we achieve O(log n) complexity.

🕒 Time & Space Complexity

Time: O(log n) — binary search halves the search space each step.

Space: O(1) — only uses constant extra memory.

class Solution { 
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==1) return 0;
        if(nums[0]>nums[1] ) return 0;
        if(nums[nums.size()-1]>nums[nums.size()-2]) return nums.size()-1;

        int low = 1;
        int high = nums.size()-2;
        while(low<=high){
            int mid = (low+high)/2;
            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) return mid; 
            else if(nums[mid]>=nums[mid-1]) low = mid+1;
            else high = mid-1;
        }
        return -1;
    }
};
