ðŸ§© Binary Search â€“ Notes

Problem:
Given a sorted array and a target, find the index of the target element.
If not found, return -1.

Key Points:

Works only on sorted search spaces (array or range).

Repeatedly divide the search space in half.

Compare the middle element with the target to decide which half to continue searching in.

Time Complexity: O(log n)

Space Complexity: O(1)

remember : Always ensure the search space is sorted, use mid = low + (high - low)/2, adjust bounds carefully based on comparison,
          and remember binary search applies to any monotonic (sorted) condition, not just arrays.

Iterative approach

int search(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (nums[mid] == target) return mid;
        else if (target > nums[mid]) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}

Recursive approach

int binarySearch(vector<int>& nums, int low, int high, int target) {

    if (low > high) return -1; //Base case.

    // Perform the steps:
    int mid = (low + high) / 2;
    if (nums[mid] == target) return mid;
    else if (target > nums[mid])
        return binarySearch(nums, mid + 1, high, target);
    return binarySearch(nums, low, mid - 1, target);
}

int search(vector<int>& nums, int target) {
    return binarySearch(nums, 0, nums.size() - 1, target);
}

