ğŸ§® Notes â€“ Finding the Square Root (Floor of âˆšn)

Problem:
Given a positive integer n, find the floor of its square root â€” i.e., the greatest integer x such that xÂ² â‰¤ n.

Key Idea:
Use binary search to efficiently find the integer square root by checking midpoints between 1 and n.

Steps:

Initialize search range â†’ low = 1, high = n.

Compute mid = (low + high) / 2 and val = mid * mid.

If val â‰¤ n, move right (low = mid + 1) â€” because mid could be a valid root, but there might be a larger one.

If val > n, move left (high = mid - 1).

At the end, high will point to the floor of âˆšn.

Why it works:
Weâ€™re searching for the largest integer whose square doesnâ€™t exceed n, and binary search efficiently narrows that down.

Complexity:

â± Time: O(log n)

ğŸ’¾ Space: O(1)

âš™ï¸ Remember for Future Problems

You can apply this same Binary Search on Answer technique when:

The answer lies in a numeric range, not an array index.

Thereâ€™s a monotonic relationship (increasing or decreasing behavior).

You can define a check function that tells whether a candidate answer works.

int floorSqrt(int n) {
    int low = 1, high = n, ans = 0;

    while (low <= high) {
        long long mid = low + (high - low) / 2;
        long long sq = mid * mid;

        if (sq == n)
            return mid; // perfect square
        else if (sq < n) {
            ans = mid;   // store possible answer
            low = mid + 1;
        } else
            high = mid - 1;
    }

    return ans; // floor value of sqrt(n)
}
