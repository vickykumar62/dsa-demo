ðŸ§© Problem: Find Peak Element

Statement:
Given an integer array nums, find a peak element â€” an element that is strictly greater than its neighbors.
Return the index of any one peak element.
You may assume nums[-1] = nums[n] = -âˆž.

Goal:
Find the index of a peak element in O(log n) time.

ðŸ’¡ Key Idea / Observation

A peak element satisfies:
nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]

The array has a â€œmountain-likeâ€ structure â€” if you move in the direction of the higher neighbor, youâ€™ll eventually reach a peak.

So, using binary search logic, you can decide which half to explore next.

âš™ï¸ Algorithm (Binary Search)

Handle edge cases first:

If array size is 1 â†’ only element is the peak.

If first element is greater than the second â†’ peak is at index 0.

If last element is greater than the second last â†’ peak is at index n - 1.

Binary search between 1 and n - 2:

Compute mid = (low + high) / 2

If nums[mid] is greater than both neighbors â†’ return mid

If the slope is ascending (nums[mid] >= nums[mid - 1]) â†’ move right

Else â†’ move left

If no peak found (theoretically shouldnâ€™t happen), return -1.

ðŸ§  Why Binary Search Works

If nums[mid] > nums[mid - 1], you are on an ascending slope â€” so a peak must exist to the right.

If nums[mid] < nums[mid - 1], you are on a descending slope â€” so a peak must exist to the left.

Hence, by halving the search space each time, we achieve O(log n) complexity.

ðŸ•’ Time & Space Complexity

Time: O(log n) â€” binary search halves the search space each step.

Space: O(1) â€” only uses constant extra memory.

class Solution { 
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==1) return 0;
        if(nums[0]>nums[1] ) return 0;
        if(nums[nums.size()-1]>nums[nums.size()-2]) return nums.size()-1;

        int low = 1;
        int high = nums.size()-2;
        while(low<=high){
            int mid = (low+high)/2;
            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) return mid; 
            else if(nums[mid]>=nums[mid-1]) low = mid+1;
            else high = mid-1;
        }
        return -1;
    }
};
