🧠 Notes: Smallest Divisor Given a Threshold (Binary Search on Answer)
🧩 Problem Statement

We are given an integer array nums and a threshold.
We need to find the smallest positive integer divisor such that the sum of each element divided by the divisor (rounded up) is ≤ threshold.

Formally:
Find the minimum d such that threshold
∑ceil(nums[i]/d)≤threshold
⚙️ Approach — Binary Search on Answer

Observation:

If we choose a small divisor, the sum will be large.

If we choose a large divisor, the sum will be small.
→ So, the answer is monotonic → we can use Binary Search.

Search Space:

Lowest divisor = 1 (smallest possible positive integer).

Highest divisor = max(nums) (if we divide by the largest number, sum = number of elements).

Check Function (sum_of_quotient)

For a given divisor, calculate the sum of ceil divisions:

sum += ceil(double(num) / divisor);


✅ But instead of floating-point division, we use integer ceil trick for efficiency:

sum += (num + divisor - 1) / divisor;  // integer ceil division

🧱 Time Complexity

O(N log M)
where N = size of nums, M = max value in nums.

💡 Key Takeaways

✅ Binary Search on Answer is used when the result space (not array index) is monotonic.

✅ Ceil trick → (a + b - 1) / b gives integer ceiling.

✅ Avoid floating-point arithmetic for better precision and speed.

✅ Always use long long when dealing with large multiplications or sums.

class Solution {
public:
    long long sum_of_quotient(const vector<int>& nums, int divisor) {
        long long sum = 0;
        for (int num : nums) {
            sum += (num + divisor - 1) / divisor; // integer ceil division
        }
        return sum;
    }

    int smallestDivisor(vector<int>& nums, int threshold) {
        int low = 1; // ✅ divisor starts from 1
        int high = *max_element(nums.begin(), nums.end());
        int ans = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            long long total = sum_of_quotient(nums, mid);

            if (total <= threshold) {
                ans = mid;
                high = mid - 1; // try smaller divisor
            } else {
                low = mid + 1;  // need bigger divisor
            }
        }

        return ans;
    }
};

